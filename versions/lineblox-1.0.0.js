let BNodes = {blocks: [], toolbox: {}};class LineBlox{    #canvas;    #ctx;    #startingBlock = "__start__";    #mouseX = 0;    #mouseY = 0;    #mouseDown = false;    #dragging = false;    draggingNode = null;    draggingNodePoint = null;    #prevDraggingNodePoint = null;    draggingScrollbarX = false;    draggingScrollbarY = false;    #xOffset = 0;    #xnOffset = 0;    #yOffset = 0;    #tbTotalOffset = 0;    #frame = 0;    scrollX = 0;    scrollY = 0;    scrollBarX = 0;    scrollBarY = 0;    scrollBarXOffset = 0;    scrollBarYOffset = 0;    scrollIntensityX = 1;    scrollIntensityY = 1;    interacted = false;    updateCallback = null;    toolbox = {        usingTB: false,        canvas: null,        ctx: null,        size: { x: 0, y: 0 },        mousePos: { x: 0, y: 0 },        clickedFrame: false,        selected: -1,        draggingNodeID: null,        scrollBarY: 0,        draggingScrollbarY: false,        scrollBarYOffset: 0,        scrollY: 0    };    get mouseX(){ return this.#mouseX }    get mouseY(){ return this.#mouseY }    get mouseDown(){ return this.#mouseDown }    get dragging(){ return this.#dragging }    get prevDraggingNodePoint(){ return this.#prevDraggingNodePoint }    get ctx(){ return this.#ctx }    get yOffset(){ return this.#yOffset }    get xOffset(){ return this.#xOffset }    get xnOffset(){ return this.#xnOffset }    get canvas(){ return this.#canvas }    get tbOffset(){ return this.#tbTotalOffset }    IsMouseAvailable(){        return this.#mouseDown && !(this.draggingNode || this.draggingNodePoint || this.#dragging || this.interacted || this.#dragBg);    }    #htmlctx = null;    connected = false;    fancyDraw = {        nodes: true,        lines: {            enabled: true,            glowLines: true,            gradientGlow: true        },        nodeHead: {            gradients: true,            darkerAmount: 40        }    };    nodes = [];    static drawDragNode(ctx, node, largestW, cy, inst, fontSize = 15, lw = 0, centerNode = false, x){        let w = lw != 0 ? (node.width > lw ? lw : node.width) : node.width;        let h = 30;        let offsetY = 0;        let maxIO = Math.max(node.inputs.length, node.outputs.length);        h = h + 5 + maxIO * 15;        let _x = largestW + 10 + (centerNode ? (x - largestW - 20 - w)/2 : 0);        const rounding = 5;        ctx.fillStyle = node.color;        if(inst.fancyDraw.nodes){            if(inst.fancyDraw.nodeHead.gradients){                const grad = ctx.createRadialGradient(_x, cy, w, _x, cy, 5);                grad.addColorStop(1, node.color);                grad.addColorStop(0, ColUtil.darkenColor(node.color, inst.fancyDraw.nodeHead.darkerAmount ?? 40));                ctx.fillStyle = grad;            }            ctx.beginPath();            ctx.roundRect(_x, cy, w, 20, [rounding, rounding, 0, 0]);            ctx.fill();            ctx.beginPath();            ctx.globalAlpha = 0.5;            ctx.roundRect(_x, cy + 20, w, h - 20, [0, 0, rounding, rounding]);            ctx.fill();            ctx.globalAlpha = 1;        }else ctx.fillRect(_x, cy, w, h);        ctx.fillStyle = "white";        ctx.textAlign = "center";        ctx.textBaseline = "top";        ctx.fillStyle = "white";        ctx.font = "15px Sans-Serif";        ctx.fillText(node.name, _x + w / 2, cy + 5, w);        offsetY = 0;        for(let input of node.inputs){            const by = cy + 30 + offsetY;            ctx.font = fontSize + "px Sans-Serif";            ctx.textAlign = "left";            ctx.textBaseline = "middle";            ctx.fillText(`${input.name}`, _x + 10, by, w / 2);            if(input.type == "Connect") BNode._drawTriangle(ctx, _x + 1, by - 5.5, 11);            else{                ctx.beginPath();                ctx.arc(_x, by, 5, 0, 2 * Math.PI);                ctx.fill();            }            offsetY += 15;        }        offsetY = 0;        for(let output of node.outputs){            const nx = _x + w - 10;            const by = cy + 30 + offsetY;            if(output.hideInput) continue;            if(output.type == "Connect") BNode._drawTriangle(ctx, nx + 11, by - 5.5, 11);            else{                ctx.beginPath();                ctx.arc(nx + 10, by, 5, 0, 2 * Math.PI);                ctx.fill();            }            ctx.font = fontSize + "px Sans-Serif";            ctx.textAlign = "right";            ctx.textBaseline = "middle";            const text = `${output.name} ${(output.type !== "Any" && output.type !== "Connect" && output.intergrated) ? "(" + output.type + ")" : ""}`;            ctx.fillText(text, nx, by, w / 2);            offsetY += 15;        }        return h;    }    drawGrid(){        const gridSize = 30;        const step = gridSize * 1;        this.#ctx.strokeStyle = "#555";         this.#ctx.lineWidth = 1;        for(let x = (-this.scrollBarX * this.scrollIntensityX) % step; x < this.#canvas.width; x += step){            this.#ctx.beginPath();            this.#ctx.moveTo(x, 0);            this.#ctx.lineTo(x, this.#canvas.height);            this.#ctx.stroke();        }        for(let y = (-this.scrollBarY * this.scrollIntensityY) % step; y < this.#canvas.height; y += step){            this.#ctx.beginPath();            this.#ctx.moveTo(0, y);            this.#ctx.lineTo(this.#canvas.width, y);            this.#ctx.stroke();        }    }    #dragBgX = 0;    #dragBgY = 0;    #dragSSX = 0;       #dragSSY = 0;       #dragBg = false;    static wrapStr(v, isNum){        if(v === undefined || v === null) return undefined;         if(isNum) return v;        if((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))){            return v;        }        return `"${v}"`;    }    drawLoop = (execReqFrame = false) => {        const ctx = this.#ctx;        ctx.clearRect(0, 0, this.#canvas.width, this.#canvas.height);        this.drawGrid();        if(this.draggingNode != null || this.draggingNodePoint != null || this.draggingScrollbarX || this.draggingScrollbarY) this.#dragging = true;        else this.#dragging = false;        if(!this.#mouseDown){            if(this.draggingNodePoint){                this.#prevDraggingNodePoint = this.draggingNodePoint;                this.draggingNodePoint = null;            }            else if(this.#prevDraggingNodePoint && !this.draggingNodePoint) this.#prevDraggingNodePoint = null;        }        let maxX = 0;        let maxY = 0;        const bD = 50;          for (let node of this.nodes.slice()) {            node.draw(ctx);            const x = (node.x + node.width) + bD - this.#canvas.width;            const y = (node.y + node.height) + bD - this.#canvas.height;            if(x > maxX){                maxX = x;            }            if(y > maxY){                maxY = y;            }        }        this.scrollX = maxX;        this.scrollY = maxY;        this.drawScrollbar(this);        if(this.#mouseDown && !this.#dragging){            if(this.#frame > 1){                this.#mouseDown = false;                this.#frame = 0;            }else                this.#frame++;        }else{            this.#frame = 0;        }        if(this.toolbox.draggingNodeID){            this.#ctx.globalAlpha = 0.5;            LineBlox.drawDragNode(this.#ctx, this.toolbox.draggingNodeID, this.#mouseX - 10, this.#mouseY, this, 15);            this.#ctx.globalAlpha = 1;        }        this.drawToolbox(this);        this.toolbox.clickedFrame = false;        if(this.updateCallback)            this.updateCallback();        if(execReqFrame)            requestAnimationFrame(this.drawLoop);    }    #getMousePosition(event) {        let rect = this.#canvas.getBoundingClientRect();        this.#mouseX = event.clientX - rect.left;        this.#mouseY = event.clientY - rect.top;    }    generateNode(node, clone = false){        let inputs = node.inputs.map(h => new NodeIOHandle(h.name, h.dName ?? null, h.code ?? null, h.values, h.display, h.type ?? "Any",            h.integrated ?? false, h.hideInput ?? false, h.inputWidth ?? 0, h.ignoreText ?? false));        let outputs = node.outputs.map(h => new NodeIOHandle(h.name, h.dName ?? null, h.code ?? null, h.values,h.display, h.type ?? "Any",            h.integrated ?? false, h.hideInput ?? false, h.inputWidth ?? 0, h.ignoreText ?? false));        return new BNode(node.name, node.internalID, inputs, outputs, this.#mouseX + this.scrollBarX * this.scrollIntensityX,            this.#mouseY + this.scrollBarY * this.scrollIntensityY, node.color ?? "#eb8634", node.width ?? 200, this,            node.mutators ?? {}, node.alwaysGenerate ?? false, undefined, clone ?? false);    }    callCtxMenu(e, prevCon = null, clickedNode = null){        if(this.#htmlctx != null){            document.body.removeChild(this.#htmlctx);            this.#htmlctx = null;        }        const ctx = document.createElement("div");        ctx.style.position = "absolute";        ctx.style.left = this.#mouseX + this.#tbTotalOffset + "px";        ctx.style.top = this.#mouseY + this.#yOffset + "px";        ctx.style.padding = "10px";        ctx.style.backgroundColor = "rgb(39, 39, 39)";        ctx.style.minWidth = "5px";        ctx.style.minHeight = "5px";        ctx.style.maxHeight = "200px";        ctx.style.borderRadius = "10px";        this.draggingScrollbarX = false;        this.draggingScrollbarY = false;        const ctxc = document.body.appendChild(ctx);        if(clickedNode){            const options = [                { name: "Delete", action: () => {                    clickedNode.remove();                }},                { name: "Duplicate", action: () => {                    clickedNode.clone();                }}            ];            for(const opt of options){                const btn = document.createElement("div");                btn.textContent = opt.name;                btn.style.color = "rgba(226,226,226,1)";                btn.style.padding = "4px 6px";                btn.style.cursor = "pointer";                btn.style.fontSize = "14px";                btn.addEventListener("mouseenter", () => btn.style.backgroundColor = "rgb(60,60,60)");                btn.addEventListener("mouseleave", () => btn.style.backgroundColor = "transparent");                btn.addEventListener("click", () => {                    opt.action();                    document.body.removeChild(ctxc);                    this.#htmlctx = null;                });                ctxc.appendChild(btn);            }        }else{            for(const category of BNodes.toolbox){                const catBtn = document.createElement("div");                catBtn.textContent = category.category + " â–¶";                catBtn.style.fontSize = "14px";                catBtn.style.color = category.color ?? "rgba(226, 226, 226, 1)";                catBtn.style.padding = "2px";                catBtn.style.cursor = "pointer";                catBtn.style.position = "relative";                catBtn.style.userSelect = "none";                ctxc.appendChild(catBtn);                const subMenu = document.createElement("div");                subMenu.style.position = "absolute";                subMenu.style.fontSize = "14px";                subMenu.style.left = "100%";                subMenu.style.top = "0";                subMenu.style.backgroundColor = "rgb(50, 50, 50)";                subMenu.style.borderRadius = "5px";                subMenu.style.display = "none";                subMenu.style.padding = "5px";                subMenu.style.minWidth = "120px";                catBtn.appendChild(subMenu);                for(const nodeName of category.blocks){                    const node = BNodes.blocks.find(n => n.internalID === nodeName);                    if(!node) continue;                    const nodeBtn = document.createElement("div");                    nodeBtn.textContent = node.name;                    nodeBtn.style.color = "rgba(226, 226, 226, 1)";                    nodeBtn.style.padding = "3px";                    nodeBtn.style.fontSize = "14px";                    nodeBtn.style.cursor = "pointer";                    nodeBtn.style.userSelect = "none";                    nodeBtn.addEventListener("mouseenter", () => nodeBtn.style.backgroundColor = "rgb(70, 70, 70)");                    nodeBtn.addEventListener("mouseleave", () => nodeBtn.style.backgroundColor = "transparent");                    nodeBtn.addEventListener("click", () => {                        const bNode = this.generateNode(node);                        if(prevCon != null){                            const p = prevCon;                            p.output.connection = null;                            const c = new NodeConnection(bNode, p.node, p.output.name, bNode.name);                            if(bNode.inputs[0].type === "Connect") p.output.connection = c;                            else console.warn("Can't create connection: input[0].type is not \"Connect\".");                        }                        if(this.#htmlctx != null){                            document.body.removeChild(this.#htmlctx);                            this.#htmlctx = null;                        }                    });                    subMenu.appendChild(nodeBtn);                }                catBtn.addEventListener("mouseenter", () => subMenu.style.display = "block");                catBtn.addEventListener("mouseleave", () => subMenu.style.display = "none");            }        }        if(e) ctxc.addEventListener("contextmenu", (e) => e.preventDefault());        this.#htmlctx = ctxc;    }    GenerateCodeFromNode(node, currentCursive = 0){        const resolveOutput = (node, outputName, seen = new Set()) => {            if(!node) return "";            if(!node.uuid) return "";            const seenKey = node.uuid + ":" + outputName;            if(seen.has(seenKey)) return "";            seen.add(seenKey);            let data = {                input: {},                output: {}            };            for(let inp of node.inputs || []){                if(!inp || inp.name === "") continue;                if(!inp.connection){                    if(inp.type === "String" && !inp.values) data.input[inp.name] = `"${inp.value}"`;                    else data.input[inp.name] = inp.value;                }else{                    const fromNode = inp.connection.from;                    const fromOutputName = inp.connection.fromName;                    if(!fromNode || !fromOutputName){                        data.input[inp.name] = "";                    }else{                        data.input[inp.name] = resolveOutput(fromNode, fromOutputName);                    }                }            }            for(let out of node.outputs || []){                if(out.isMutated === false && typeof out.code === "function") {                    const result = out.code({ input: {}, output: {} });                    for(const key in result){                        if(!(key in data.output)) data.output[key] = result[key];                    }                }            }            for (let out of node.outputs || []) {                if(!out || !out.name) continue;                try{                    if(out.type === "Connect"){                        if(out.connection){                            const downstreamNode = out.connection.to;                            data.output[out.name] = downstreamNode                                ? this.GenerateCodeFromNode(downstreamNode, currentCursive+1)                                : "";                        }else{                            data.output[out.name] = "";                        }                    }else{                        if(out.value !== undefined){                            data.output[out.name] = out.value;                            data.output["name"] = out.name;                        }else if(typeof out.code === "function"){                            data.output[out.name] = out.code(data);                        }else{                            data.output[out.name] = "";                        }                    }                }catch(e){                    console.error("[resolveOutput] error evaluating out", out.name, e);                    data.output[out.name] = "";                }            }            data.inputs = data.input;            data.outputs = data.output;            const outObj = (node.outputs || []).find(o => o.name === outputName);            if(!outObj) return "";            if(typeof outObj.code === "function"){                try{                    for(let out of node.outputs || []){                        if(!out || !out.name) continue;                        if(out.type === "Connect"){                            if(out.connection) {                                const outputNode = out.connection.from;                                data.output[out.name] = this.GenerateCodeFromNode(outputNode, currentCursive+1);                            }else{                                data.output[out.name] = "";                            }                        }else{                            data.output[out.name] = out.value ?? (typeof out.code === "function" ? out.code(data) : "");                        }                    }                    return outObj.code(data);                }catch(e){                    console.error("Error in outObj.code for", node, outputName, e);                    return "";                }            }            return outObj.value ?? "";        }        let lastCon = node;        let totalCode = "";        while(lastCon != null){            const con = lastCon.outputs ? (lastCon.outputs.length < 1 ? null : lastCon.outputs[0]) : null;            if(!con){                lastCon = null;                break;            }            const incon = lastCon.inputs[0];                let givingCodeData = {                input: {},                output: {}            };            for(let inp of lastCon.inputs || []){                if(!inp || inp.name == "") continue;                if(!inp.connection){                    if(inp.type === "String" && !inp.values) givingCodeData.input[inp.name] = `"${inp.value}"`;                    else givingCodeData.input[inp.name] = inp.type !== "Any" ? inp.value : `"${inp.value}"`;                }else{                    const fromNode = inp.connection.from;                    const fromOutputName = inp.connection.fromName;                    if(!fromNode || !fromOutputName){                        givingCodeData.input[inp.name] = "";                    }else{                        try{                            givingCodeData.input[inp.name] = resolveOutput(fromNode, fromOutputName);                         }catch(e){                            throw new Error("Error generating code from resolveOutput: " + e);                        }                    }                }            }            for(let out of lastCon.outputs){                if(out.name == "") continue;                if(out.connection == null) givingCodeData["output"][out.name] = "";                else{                    const outputObj = out.connection.from;                    let result = null;                    try{                        result = this.GenerateCodeFromNode(outputObj, currentCursive+1);                    }catch(e){                        throw new Error("Error generating code from node: " + e);                    }                    givingCodeData["output"][out.name] = result;                }            }            givingCodeData.inputs = givingCodeData.input;            givingCodeData.outputs = givingCodeData.output;            const code = incon ? (incon.code ? incon.code(givingCodeData) : "") : "";            function indentCode(code, indentLevel) {                if (indentLevel < 0) indentLevel = 0;                let currentIndent = indentLevel;                const lines = code.split("\n");                return lines.map(line => {                    const trimmed = line.trim();                    if (trimmed.startsWith("}")) currentIndent--;                    const tabs = "\t".repeat(Math.max(currentIndent, 0));                    const result = tabs + trimmed;                    if (trimmed.endsWith("{")) currentIndent++;                    return result;                }).join("\n");            }            totalCode += indentCode(code, currentCursive);            lastCon = con.connection ? con.connection.from : null;        }        return totalCode;    }    GenerateCode(){        const start = this.nodes.find(n => n.internalName === this.#startingBlock);        if (!start) return "";        const code = this.GenerateCodeFromNode(start);        return code;    }    GetWorkspace(){        const nodes = [];        for(let node of this.nodes){            const nodeJson = {                uuid: node.uuid,                internalName: node.internalName,                x: node.x,                y: node.y,                inputs: node.inputs.map(h => ({                    name: h.name,                    dName: h.dName ?? h.name,                    type: h.type,                    value: h.value,                    ...(h.display ? {display: h.display} : {}),                    ...(h.integratedInput ? {integrated: h.integratedInput} : {}),                    ...(h.values ? {values: h.values} : {}),                    ...(h.display != "" ? {display: h.display} : {}),                    ...(h.hideInput != false ? {hideInput: h.hideInput} : {}),                    ...(h.inputWidth != 0 ? {inputWidth: h.inputWidth} : {}),                    ...(h.ignoreText != false ? {ignoreText: h.ignoreText} : {}),                    ...(h.isMutated != false ? {isMutated: h.isMutated} : {}),                    connection: h.connection ? {                        fromName: h.connection.fromName ?? "",                        toName: h.connection.toName ?? "",                        fromUUID: h.connection.from?.uuid ?? "",                        toUUID: h.connection.to?.uuid ?? "",                        code: null                    } : null                })),                outputs: node.outputs.map(h => ({                    name: h.name,                    dName: h.dName ?? h.name,                    type: h.type,                    value: h.value,                    ...(h.display ? {display: h.display} : {}),                    ...(h.integratedInput ? {integrated: h.integratedInput} : {}),                    ...(h.values ? {values: h.values} : {}),                    ...(h.display != "" ? {display: h.display} : {}),                    ...(h.hideInput != false ? {hideInput: h.hideInput} : {}),                    ...(h.inputWidth != 0 ? {inputWidth: h.inputWidth} : {}),                    ...(h.ignoreText != false ? {ignoreText: h.ignoreText} : {}),                    ...(h.isMutated != false ? {isMutated: h.isMutated} : {}),                    connection: h.connection ? {                        fromName: h.connection.fromName ?? "",                        toName: h.connection.toName ?? "",                        fromUUID: h.connection.from?.uuid ?? "",                        toUUID: h.connection.to?.uuid ?? "",                        code: null                    } : null                }))            };            console.log(nodeJson.outputs);            nodes.push(nodeJson);        }        return nodes;    }    SetWorkspace(w){        let ws = [];        if(typeof w === "string"){            ws = JSON.parse(w);        }else if(Array.isArray(w)){            ws = w;        }else{            console.warn("no valid format! (" + typeof w + ")");            return;        }        const nodeMap = {};        const createNodeIOHandle = (h) => {            const n = new NodeIOHandle(h.name, h.dName ?? null, h.code ?? null, h.values ?? undefined, h.display ?? "", h.type ?? "Any",                h.integrated ?? false, h.hideInput ?? false, h.inputWidth ?? 0, h.ignoreText ?? false);            n.isMutated = h.isMutated ?? false;            return n;        }        for(let node of ws){            let inputs = [];            let outputs = [];            const jn = BNodes.blocks.find(n => n.internalID === node.internalName);            for(let h of node.inputs){                const n = createNodeIOHandle(h);                n.value = h.value;                inputs.push(n);            }            for(let h of node.outputs){                const n = createNodeIOHandle(h);                n.value = h.value;                outputs.push(n);            }            const newNode = new BNode(jn.name, node.internalName, inputs, outputs,                node.x, node.y, jn.color, jn.width, this, jn.mutators ?? {}, jn.alwaysGenerate, node.uuid);            nodeMap[node.uuid] = newNode;        }        for(let node of ws){            const n = this.nodes.find(n => n.uuid == node.uuid);            const bn = BNodes.blocks.find(b => b.internalID === n.internalName);            n.inputs.forEach((inp, i) => {                inp.code = bn.inputs[i]?.code ?? (() => "");            });            n.outputs.forEach((out, i) => {                out.code = bn.outputs[i]?.code ?? (() => "");            });            let i = 0;            for(let h of node.inputs){                if(h.connection == undefined || (i == 0 && h.name == "")){                    i++;                    continue;                }                const fromNode = this.nodes.find(n => n.uuid == h.connection.fromUUID);                const toNode = this.nodes.find(n => n.uuid == h.connection.toUUID);                const con = new NodeConnection(fromNode, toNode,                    h.connection.fromName, h.connection.toName);                n.inputs[i].connection = con;                n.code = bn.inputs[i]?.code ?? null;                i++;            }            i = 0;            for(let h of node.outputs){                if(h.connection == undefined){                    i++;                    continue;                }                const fromNode = this.nodes.find(n => n.uuid == h.connection.fromUUID);                const toNode = this.nodes.find(n => n.uuid == h.connection.toUUID);                if(!fromNode || !toNode){                    i++;                    continue;                }                const con = new NodeConnection(fromNode, toNode,                    h.connection.fromName, h.connection.toName);                n.outputs[i].connection = con;                n.code = bn.outputs[i].code ?? null;                i++;            }        }    }    getNodeAt(x, y){        for(const node of this.nodes){            const drawX = node.x - this.scrollBarX * this.scrollIntensityX;            const drawY = node.y - this.scrollBarY * this.scrollIntensityY;            if(x >= drawX && x <= drawX + node.width &&                y >= drawY && y <= drawY + node.height){                return node;            }        }        return null;    }    ExecuteCode(){        const code = this.GenerateCode();        console.log("========EXEC START========");        try{            eval(code);        }catch(e){            console.error("error during code execution: " + e);        }        console.log("=========EXEC END=========");    }    constructor(startNId = null, top = 0, left = 0, right = 0, tbNodes = [], toolboxW = 0){        const canvasTop = top;        const canvasLeft = left;        BNodes.toolbox = tbNodes;        if(startNId) this.#startingBlock = startNId;        const cnv = document.createElement("canvas");        cnv.id = "main";        const canvas = document.body.appendChild(cnv);        const w = canvasLeft + (toolboxW > 99 ? toolboxW + 2 : 0);        this.#tbTotalOffset = w;        cnv.addEventListener("contextmenu", (e) => {            e.preventDefault();            const mx = e.clientX - w;            const my = e.clientY - canvasTop;            const clickedNode = this.getNodeAt(mx, my);            this.callCtxMenu(e, null, clickedNode);        });        canvas.style.position = "absolute";        canvas.style.top = canvasTop + "px";        canvas.style.left = w + "px";        canvas.style.height = "calc(100% - " + canvasTop + "px)";        canvas.style.width = "calc(100% - " + (w + right) + "px)";        canvas.style.zIndex = "-101";        canvas.width = window.innerWidth - (w + right);        canvas.height = window.innerHeight - canvasTop;        this.#canvas = canvas;        this.#yOffset = canvasTop;        this.#xOffset = canvasLeft        this.#xnOffset = right;        this.#ctx = canvas.getContext("2d");        if(toolboxW > 99){            const tb = document.createElement("canvas");            tb.style.position = "absolute";            tb.style.top = canvasTop + "px";            tb.style.left = canvasLeft + "px";            tb.style.height = "calc(100% - " + canvasTop + "px)";            tb.style.width = toolboxW + "px";            tb.style.zIndex = "-99";            tb.style.background = getComputedStyle(document.body).backgroundColor;            const toolbox = document.body.appendChild(tb);            toolbox.width = toolboxW;            toolbox.height = window.innerHeight - canvasTop;            toolbox.addEventListener("mousedown", (e) => {                this.toolbox.clickedFrame = true;            });            toolbox.addEventListener("mouseup", (e) => {                this.toolbox.draggingScrollbarY = false;            });            this.toolbox.usingTB = true;            this.toolbox.canvas = toolbox;            this.toolbox.size.x = toolboxW;            this.toolbox.size.y = canvasTop;            this.toolbox.ctx = toolbox.getContext("2d");        }        window.addEventListener("mousemove", (e) => {            this.toolbox.mousePos.x = e.clientX - canvasLeft;            this.toolbox.mousePos.y = e.clientY - canvasTop;            this.#getMousePosition(e);        });        window.addEventListener("mouseup", (e) => {            this.#mouseDown = false;            this.#dragBg = false;            this.draggingNode = null;            this.draggingScrollbarX = false;            this.draggingScrollbarY = false;            this.toolbox.draggingScrollbarY = false;            this.toolbox.draggingNodeID = null;            this.interacted = false;        });        this.#canvas.addEventListener("mousedown", (e) => {            this.#mouseDown = true;            if(this.#htmlctx != null){                document.body.removeChild(this.#htmlctx);                this.#htmlctx = null;            }        });        this.#canvas.addEventListener("mouseup", (e) => {            const node = this.toolbox.draggingNodeID;            if(node){                this.generateNode(node);                this.toolbox.draggingNodeID = null;                return;            }        });        const updateCanvasSize = () => {            canvas.width = window.innerWidth - (w + right);            canvas.height = window.innerHeight - canvasTop;            if (this.toolbox) {                this.toolbox.canvas.height = window.innerHeight - canvasTop;            }            this.drawLoop();        };        window.addEventListener("resize", updateCanvasSize);        const resizeObserver = new ResizeObserver(updateCanvasSize);        resizeObserver.observe(document.body);        this.drawLoop(true);    }    static _escapeForStr(str) {        if (!str) return "";        const first = str[0] === '"' ? '"' : "";        const last = str[str.length - 1] === '"' ? '"' : "";        const inner = str.slice(first ? 1 : 0, last ? -1 : str.length)            .replace(/\\/g, '\\\\')            .replace(/"/g, '\\"')            .replace(/\n/g, '\\n')            .replace(/\r/g, '\\r')            .replace(/\t/g, '\\t');        return first + inner + last;    }}
class BNode{    #name = "";    #intName = "";    #inputs;    #outputs;    #alwaysGenerate = false;    #uuid = 0;    #stopExec = false;    #x = 0;    #y = 0;    #dragOffsetX = 0;    #dragOffsetY = 0;    #inst = null;    #na = null;    #w = 200;    #h = 0;    #mutators = {        state: {            inputs: {                amount: 0,                data: []            },            outputs: {                amount: 0,                data: []            }        },        internalJson: {},        hasInputMut: false,        hasOutputMut: false    };    color;    get inputs(){ return this.#inputs; }    get outputs(){ return this.#outputs; }    get name(){ return this.#name }    get x(){ return this.#x }    get y(){ return this.#y }    get width(){ return this.#w }    get height(){ return this.#h }    get internalName(){ return this.#intName }    get uuid(){ return this.#uuid }    get alwaysGenerate(){ return this.#alwaysGenerate }    get mutatorState(){ return this.#mutators.state }    get fullMutatorData(){ return this.#mutators }    SetUuid(uuid){        this.#uuid = uuid;    }    setPos(x, y){        this.#x = x;        this.#y = y;    }    #addMutator(type){        type += "s";        const state = this.#mutators.state[type];        const nextIndex = state.amount++;        const _newIO = this.#mutators.internalJson[type].code({ amount: nextIndex });        const newIO = new NodeIOHandle(_newIO.name, _newIO.dName, _newIO.code, _newIO.values ?? undefined, _newIO.display,            _newIO.type ?? "Any", _newIO.integrated ?? false, _newIO.hideInput ?? false, _newIO.inputWidth ?? false,            _newIO.inputWidth ?? 0, _newIO.ignoreText ?? false);        newIO.isMutated = true;        state.data.push(newIO);        if(type === "inputs") this.inputs.push(newIO);        else this.outputs.push(newIO);    }    #getColFromType(ct){        if (typeof ct === "string" && (ct.startsWith("#") || ct.startsWith("rgb"))) {            return ct;        }        ct = (ct ?? "").toString().toLowerCase();;        let col = "white";        switch(ct){            case "string":                col = "orange";                break;            case "number":            case "integer":            case "float":                col = "lightgreen";                break;            case "boolean":                col = "rgba(0, 89, 255, 1)";                break;            case "variable":                col = "purple";                break;            default:                col = "white";                break;        }        return col;    }    #drawConnection(x, y, toX, toY, isCon = false, conType = "na", color = ""){        const ctx = this.#inst.ctx;        let col = color == "" ? this.#getColFromType(conType) : color;        ctx.strokeStyle = col;        ctx.globalAlpha = 1;        ctx.beginPath();        ctx.lineWidth = 2;        if(this.#inst.fancyDraw.lines.enabled){            ctx.save();            if(this.#inst.fancyDraw.lines.glowLines){                if(this.#inst.fancyDraw.lines.gradientGlow){                    const grad = ctx.createLinearGradient(x, y, toX, toY);                    grad.addColorStop(0, col);                    grad.addColorStop(1, "white");                    ctx.strokeStyle = grad;                }else ctx.strokeStyle = col;                ctx.lineWidth = 4;                ctx.shadowColor = col;                ctx.shadowBlur = 10;            }            const dx = (isCon ? 1 : -1) * Math.abs(toX - x) * 0.5;            ctx.beginPath();            ctx.moveTo(x, y);            ctx.bezierCurveTo(                x - dx, y,                toX + dx, toY,                toX, toY            );            ctx.stroke();            ctx.restore();        }else{            ctx.moveTo(x, y);            ctx.lineTo(toX, toY);            ctx.stroke();        }    }    #drawTriangle(px, py, psize){ BNode._drawTriangle(this.#inst.ctx, px, py, psize) }    static _drawTriangle(ctx, px, py, psize){        const size = psize / 2;        const x = px - size;        const y = py + size;        ctx.strokeStyle = "white";        ctx.beginPath();        ctx.moveTo(x, y + size);        ctx.lineTo(x + psize / 1.25, y);        ctx.lineTo(x, y - size);        ctx.lineTo(x, y + size);        ctx.fill();        ctx.stroke();    }    clone(){        const create = (h) => {            const n = new NodeIOHandle(h.name, h.dName, h.code, h.values, h.display, h.type, h.integratedInput, h.hideInput,                h.inputWidth, h.ignoreText);            n.value = h.value;            n.isMutated = h.isMutated;            return n;        }        const inp = this.#inputs.map(h => create(h));        const out = this.#outputs.map(h => create(h));        const node = new BNode(this.#name, this.#intName, inp, out,            this.#x + 30, this.#y + 30, this.color, this.#w, this.#inst, undefined, true);        return node;    }    remove(){        this.#stopExec = true;        this.#inst.nodes = this.#inst.nodes.filter(n => n !== this);        for(const h of this.#inputs){            if(h._htmlInput) document.body.removeChild(h._htmlInput);        }        for(const h of this.#outputs){            if(h._htmlInput) document.body.removeChild(h._htmlInput);        }        this.#inputs = [];        this.#outputs = [];        this.#uuid = null;        this.#inst = null;        this.#na = null;        return;    }    #drawHtmlInput(input, w, x, by, ax = 0, ay = 0, inputt = true, textW = 0){        if(input?.type !== "Connect" && input?.integratedInput && input?.connection == null){            const inputLeft = x + ax + 5 + this.#inst.tbOffset - (inputt ? 0 : 8);            const inputTop = by - 10 + ay + this.#inst.yOffset + 0;            let elemWidth = input.inputWidth > 0 ? input.inputWidth : w / 2;            if(!input._htmlInput){                let htmlElement;                if(input.values){                    htmlElement = document.createElement("select");                    let i = 0;                    for(const val of input.values){                        const opt = document.createElement("option");                        opt.value = val.val;                        opt.textContent = val.dsp;                        htmlElement.appendChild(opt);                        if (input.value === val.val) opt.selected = true;                        if ((!input.value || input.value === "") && i === 0) opt.selected = true;                        i++;                    }                    input.value = htmlElement.value;                    htmlElement.addEventListener("change", () => {                        input.value = htmlElement.value;                    });                    htmlElement.style.width = elemWidth + 17 + "px";                    htmlElement.style.height = "15px";                }else{                    htmlElement = document.createElement("input");                    htmlElement.type = input.type === "Boolean" ? "checkbox" : input.type === "Number" ? "number" : "text";                    if(input.type === "Boolean")                        htmlElement.checked = input.value === true;                    else                        htmlElement.value = input.value != "" && input.value != null ? input.value : "";                    htmlElement.style.width = elemWidth + "px";                    htmlElement.style.height = "10px";                    input.value = input.type === "Boolean" ? htmlElement.checked : htmlElement.value;                    htmlElement.addEventListener("input", () => {                        if(input.type === "Number") input.value = parseFloat(htmlElement.value);                        else if(input.type === "Boolean") input.value = htmlElement.checked;                        else input.value = htmlElement.value;                    });                }                htmlElement.style.position = "absolute";                htmlElement.style.zIndex = "-100";                htmlElement.style.fontSize = "10px";                document.body.appendChild(htmlElement);                input._htmlInput = htmlElement;            }            if(inputt){                input._htmlInput.style.left = inputLeft + "px";                input._htmlInput.style.right = "auto";            }else{                input._htmlInput.style.left = "auto";                input._htmlInput.style.right = this.#inst.canvas.width - (x + w - textW) + "px";            }            input._htmlInput.style.top = inputTop + 2 + "px";            input._htmlInput.style.pointerEvents = this.#inst.dragging ? "none" : "auto";        }else if(input._htmlInput != null){            document.body.removeChild(input._htmlInput);            input._htmlInput = null;        }    }    #hideHtmlInputs(h_ = null){        const removeInput = (h) => {            if (h._htmlInput) {                h._htmlInput.parentNode.removeChild(h._htmlInput);                h._htmlInput = null;            }        };        if(!h_){            for(let h of this.#inputs) removeInput(h);            for(let h of this.#outputs) removeInput(h);        }else   removeInput(h_);    }    draw(ctx){        if(this.#stopExec) return;        const inst = this.#inst;        let x = this.#x - this.#inst.scrollBarX * this.#inst.scrollIntensityX;        let y = this.#y - this.#inst.scrollBarY * this.#inst.scrollIntensityY;        const fontSize = 12;        const ts = this;        const nodeConSpace = 15;        const w = this.#w;        if(this.#x < 0){            x = 0 - this.#inst.scrollBarX;            this.#x = x;        }        if(this.#y < 0){            y = 0 - this.#inst.scrollBarY;            this.#y = y;        }        const baseOffset = 30;        let h = baseOffset;        let offsetY = 0;        let maxIO = Math.max(this.#inputs.length, this.#outputs.length);        h = baseOffset + 5 + maxIO * 15;        if(x > this.#inst.canvas.width || x < -w || y < 0 - h || y > this.#inst.canvas.height){            this.#hideHtmlInputs();            offsetY = 0;            for(let input of this.#inputs){                const by = y + baseOffset + offsetY;                if(input.connection){                    const p = input.connection;                    const outputIndex = p.from.outputs.findIndex(o => o.name === p.fromName);                    let inputColor = this.#getColFromType(input.type);                    if (outputIndex === -1){                        console.error("Error drawing line! node disconnected.");                        input.connection = null;                        return;                    }                    if(input.connection && input.connection.from){                        const output = input.connection.from.outputs.find(o => o.name === input.connection.fromName);                        const outputType = output.display != "" ? output.display : !Array.isArray(output.type) ? output.type : "rgb(255, 255, 255)";                        if(outputType) inputColor = this.#getColFromType(outputType);                    }                    const fromY = (p.from.y + baseOffset + outputIndex * nodeConSpace) - this.#inst.scrollBarY * this.#inst.scrollIntensityY;                    const fromX = p.from.x + p.from.width - this.#inst.scrollBarX * this.#inst.scrollIntensityX;                    this.#drawConnection(fromX, fromY, x, by, false, input.type, inputColor);                }                offsetY += nodeConSpace;            }            ctx.fillStyle = "white";            offsetY = 0;            for(let output of this.#outputs){                const by = y + baseOffset + offsetY;                if(output.connection){                    const p = output.connection;                    const outputIndex = p.from.inputs.findIndex(o => o.name === p.fromName);                    if (outputIndex === -1){                        console.error("Error drawing line! node disconnected. [not found: " + this.#name + "]");                        output.connection = null;                        return;                    }                    const fromY = (p.from.y + baseOffset + outputIndex * nodeConSpace) - this.#inst.scrollBarY * this.#inst.scrollIntensityY;                    const fromX = p.from.x - this.#inst.scrollBarX * this.#inst.scrollIntensityX;                    this.#drawConnection(fromX, fromY, x + w, by, true,                        this.#getColFromType(output.display != "" ? output.display : !Array.isArray(output.type) ? output.type : "rgb(255, 255, 255)"));                }                offsetY += nodeConSpace;            }            return;        }        const rounding = 5;        ctx.fillStyle = this.color;        if(this.#inst.fancyDraw.nodes){            if(this.#inst.fancyDraw.nodeHead.gradients){                const grad = ctx.createRadialGradient(x, y, w, x, y, 5);                grad.addColorStop(1, this.color);                grad.addColorStop(0, ColUtil.darkenColor(this.color, this.#inst.fancyDraw.nodeHead.darkerAmount ?? 40));                ctx.fillStyle = grad;            }            ctx.beginPath();            ctx.roundRect(x, y, w, 20, [rounding, rounding, 0, 0]);            ctx.fill();            ctx.beginPath();            ctx.globalAlpha = 0.5;            ctx.roundRect(x, y + 20, w, h - 20, [0, 0, rounding, rounding]);            ctx.fill();            ctx.globalAlpha = 1;        }else ctx.fillRect(x, y, w, h);        ctx.fillStyle = "white";        ctx.textAlign = "center";        ctx.textBaseline = "top";        ctx.fillStyle = "white";        ctx.font = "15px Sans-Serif";        ctx.fillText(this.#name, x + w / 2, y + 5, w);        const r = 5;            let by_ = y + baseOffset + offsetY;        let nx_ = 0;        offsetY = 0;        ctx.textBaseline = "middle";        for(let input of this.#inputs){            const by = y + baseOffset + offsetY;            ctx.fillStyle = "white";            ctx.font = fontSize + "px Sans-Serif";            ctx.textAlign = "left";            ctx.textBaseline = "middle";            const text = input.dName;            ctx.fillText(text, x + 10, by, w / 2);            const defCol = "rgb(255, 255, 255)";            let inputColor = this.#getColFromType(input.display ? input.display : !Array.isArray(input.type) ? input.type : defCol);            if(input.connection && input.connection.from){                const output = input.connection.from.outputs.find(o => o.name === input.connection.fromName);                const outputType = output ? output.display != "" ? output.display : !Array.isArray(output.type) ? output.type : defCol : defCol;                if(outputType) inputColor = this.#getColFromType(outputType);            }            const textW = ctx.measureText(text).width;            const tx = x + 5 + (input.ignoreText ? 0 : textW);            this.#drawHtmlInput(input, w / 2, tx, by);            if(input.isMutated){                const a = 2;                    const bs = fontSize+a;                const __x = tx + textW*2;                const mouse = {                    x: inst.mouseX,                    y: inst.mouseY                }                const mr = {                    x: __x - 28,                    y: by - (5+a),                    w: bs,                    h: bs                };                ctx.strokeStyle = "white";                ctx.beginPath();                ctx.roundRect(mr.x, mr.y, mr.w, mr.h, 2);                ctx.fill();                ctx.stroke();                ctx.fillStyle = "black";                ctx.textBaseline = "top";                ctx.textAlign = "left";                ctx.fillText("--", __x - 25, by - 5, bs);                ctx.fillStyle = "white";                ctx.textBaseline = "middle";                if(inst.IsMouseAvailable() && mouse.x >= mr.x && mouse.x <= mr.x + mr.w &&                    mouse.y >= mr.y && mouse.y <= mr.y + mr.h){                    inst.interacted = true;                    this.#hideHtmlInputs(input);                    this.#inputs = this.#inputs.filter(i => i !== input);                }            }            if(input.hideInput ?? false){                if(input.integratedInput){                    offsetY += nodeConSpace;                    by_ = by;                }                continue;            }            if (!inst.mouseDown && inst.prevDraggingNodePoint) {                const additional = 1;                const dx = inst.mouseX - x;                const dy = inst.mouseY - by;                if(dx * dx + dy * dy <= (r+additional) * (r+additional)){                    const p = inst.prevDraggingNodePoint;                    if(p.node != this){                        let canConnect = true;                        if(input.type !== "Any"){                            const inputTypes = Array.isArray(input.type) ? input.type : [input.type];                            const outputTypes = Array.isArray(p.output.type) ? p.output.type : [p.output.type];                            const hasMatch = inputTypes.includes("Any") ||                                outputTypes.includes("Any") ||                                inputTypes.some(it => outputTypes.includes(it));                            if(!hasMatch){                                canConnect = false;                            }                        }                        if(input.type === "Any" && p.output.type === "Connect") canConnect = false;                        if(canConnect){                            let canCon = true;                            let removed = false;                            if(input.connection){                                const oldCon = input.connection;                                const isSameConnection = oldCon.from === p.node &&                                    oldCon.to === this &&                                    oldCon.fromName === p.output.name &&                                    oldCon.toName === input.name;                                if(isSameConnection){                                    input.connection = null;                                    if(oldCon.from){                                        const out = oldCon.from.outputs.find(o => o.connection === oldCon);                                        if(out) out.connection = null;                                    }                                    removed = true;                                }else{                                    input.connection = null;                                    if(oldCon.from){                                        const out = oldCon.from.outputs.find(o => o.connection === oldCon);                                        if(out) out.connection = null;                                    }                                }                            }                            if(!removed && p.output.connection){                                const oldCon = p.output.connection;                                const isSameConnection = oldCon.from === p.node &&                                    oldCon.to === this &&                                    oldCon.fromName === p.output.name &&                                    oldCon.toName === input.name;                                if(isSameConnection){                                    p.output.connection = null;                                    if(oldCon.to){                                        const inp = oldCon.to.inputs.find(i => i.connection === oldCon);                                        if(inp) inp.connection = null;                                    }                                    removed = true;                                }else{                                    p.output.connection = null;                                    if(oldCon.to){                                        const inp = oldCon.to.inputs.find(i => i.connection === oldCon);                                        if(inp) inp.connection = null;                                    }                                }                            }                            if(!removed){                                const inputTypes = Array.isArray(input.type) ? input.type : [input.type];                                const outputTypes = Array.isArray(p.output.type) ? p.output.type : [p.output.type];                                if(input.type === "Connect"){                                    input.connection = null;                                    p.output.connection = null;                                    const c = new NodeConnection(this, p.node, input.name, p.output.name);                                    p.output.connection = c;                                }else{                                    const hasMatch = input.type === "Any" ||                                         outputTypes.some(ot => inputTypes.includes(ot));                                    const invalidAnyConnect = (input.type === "Any" && outputTypes.includes("Connect")) ||                                        (outputTypes.includes("Any") && input.type === "Connect");                                    if(hasMatch && !invalidAnyConnect){                                        input.connection = null;                                        p.output.connection = null;                                        const c = new NodeConnection(p.node, this, p.output.name, input.name);                                        input.connection = c;                                    }else{                                        console.warn(`Can't connect nodes: Type mismatch (trying to connect (${p.output.type}) with (${input.type}))`);                                        canCon = false;                                    }                                }                            }                            if(canCon) inst.connected = true;                        }else console.warn(`Can't connect nodes: Type mismatch (trying to connect (${p.output.type}) with (${input.type}))`);                    }else console.error("Can't connect node to current.");                }            }            if(input.connection){                const p = input.connection;                const outputIndex = p.from.outputs.findIndex(o => o.name === p.fromName);                if (outputIndex === -1){                    console.error("Error drawing line! node disconnected.");                    input.connection = null;                    return;                }                const fromY = (p.from.y + baseOffset + outputIndex * nodeConSpace) - this.#inst.scrollBarY * this.#inst.scrollIntensityY;                const fromX = p.from.x + p.from.width - this.#inst.scrollBarX * this.#inst.scrollIntensityX;                this.#drawConnection(fromX, fromY, x, by, false, input.type, inputColor);            }            if(input.type == "Connect") this.#drawTriangle(x + 1, by - 5.5, 11);            else{                ctx.fillStyle = inputColor;                ctx.beginPath();                ctx.arc(x, by, r, 0, 2 * Math.PI);                ctx.fill();            }            offsetY += nodeConSpace;            by_ = by;        }        if(this.#mutators.hasInputMut){            const rectX = x + 10;            const rectY = by_ + nodeConSpace - 5;            const rectW = w / 2 - 5;            const rectH = nodeConSpace;            const mx = inst.mouseX;            const my = inst.mouseY;            const w_ = 2;            ctx.lineWidth = w_;            ctx.font = fontSize + "px Sans-Serif";            ctx.textAlign = "center";            ctx.fillStyle = ColUtil.darkenColor(this.color, 20);            ctx.beginPath();            ctx.roundRect(rectX, rectY, rectW, rectH, 5);            ctx.fill();            ctx.stroke();            ctx.strokeStyle = this.color;            ctx.roundRect(rectX - w_/2, rectY - w_/2, rectW + w_/2, rectH + w_/2, 5+w_);            ctx.stroke();            ctx.lineWidth = 1;            ctx.fillStyle = "white";            ctx.fillText("Add " +                (this.#mutators.internalJson.inputs.addType == undefined ? "Mutation" : this.#mutators.internalJson.inputs.addType),                rectX + rectW/2, rectY + rectH/2, rectW);            if(inst.IsMouseAvailable() && (mx >= rectX &&                mx <= rectX + rectW &&                my >= rectY &&                my <= rectY + rectH)){                this.#addMutator("input");                inst.interacted = true;            }        }        ctx.fillStyle = "white";        offsetY = 0;        nx_ = 0;        for(let output of this.#outputs){            if(output.hideInput) continue;            const nx = x + w - 10;            const by = y + baseOffset + offsetY;            let inputColor = this.#getColFromType(output.display != "" ? output.display : !Array.isArray(output.type) ? output.type : "rgb(255, 255, 255)");            if(output.connection){                const p = output.connection;                const outputIndex = p.from.inputs.findIndex(o => o.name === p.fromName);                if (outputIndex === -1){                    console.error("Error drawing line! node disconnected. [not found: " + this.#name + "]");                    output.connection = null;                    return;                }                const fromY = (p.from.y + baseOffset + outputIndex * nodeConSpace) - this.#inst.scrollBarY * this.#inst.scrollIntensityY;                const fromX = p.from.x - this.#inst.scrollBarX * this.#inst.scrollIntensityX;                this.#drawConnection(fromX, fromY, x + w, by, true, inputColor);            }            if(output?.type == "Connect") this.#drawTriangle(nx + 11, by - 5.5, 11);            else{                ctx.fillStyle = inputColor;                ctx.beginPath();                ctx.arc(nx + 10, by, r, 0, 2 * Math.PI);                ctx.fill();            }            ctx.fillStyle = "white";            ctx.font = fontSize + "px Sans-Serif";            ctx.textAlign = "right";            ctx.textBaseline = "middle";            const text = output.dName;            ctx.fillText(text, nx, by, w / 2);            const textW = ctx.measureText(text).width;            this.#drawHtmlInput(output, w, x - (10 + output.ignoreText ? 7 : textW),                by, 0, 0, false, output.ignoreText ? 0 : 5 + textW);            if(inst.IsMouseAvailable()){                const dx = inst.mouseX - (nx + 10);                const dy = inst.mouseY - by;                if(dx * dx + dy * dy <= r * r){                    inst.draggingNodePoint = {                        node: this,                        output: output                    };                    inst.connected = false;                    inst.interacted = true;                }            }            if(inst.draggingNodePoint && inst.draggingNodePoint.output === output){                if(inst.draggingNodePoint.node == this){                    const index = this.#na.indexOf(this);                    this.#na.splice(index, 1);                    this.#na.push(this);                    this.#drawConnection(nx + 10, by, inst.mouseX, inst.mouseY);                }            }            offsetY += nodeConSpace;            by_ = by;            nx_ = nx;        }        this.#h = h;        let mx = inst.mouseX;        let my = inst.mouseY;        if(inst.IsMouseAvailable()){            if(mx < x - 10 + w && mx > x + 10 &&                my < y + h && my > y){                    inst.draggingNode = this;                    this.#dragOffsetX = mx - this.#x;                    this.#dragOffsetY = my - this.#y;                    const index = this.#na.indexOf(this);                    this.#na.splice(index, 1);                    this.#na.push(this);                    inst.interacted = true;                }        }        if(inst.draggingNode == this){            ts.setPos(mx - ts.#dragOffsetX, my - ts.#dragOffsetY);            return;        }    }    constructor(name, intName, inputs, outputs, x = 0, y = 0, col = "#eb8634", width = 200,        instance = LBInst, mutatorJSON = {}, alwaysGen = false, uuid = undefined, isClone = false){        if(!Array.isArray(inputs) || !Array.isArray(outputs)) throw new Error("Inputs or Outputs is not an array! Stopping node creation.");        if(!inputs.every(i => i instanceof NodeIOHandle)) throw new TypeError("All inputs must be NodeIOHandle");        if(!outputs.every(i => i instanceof NodeIOHandle)) throw new TypeError("All outputs must be NodeIOHandle");        this.#name = name;        this.#intName = intName;        this.#inputs = inputs;        this.#outputs = outputs;        this.#x = x;        this.#y = y;        this.color = col;        this.#inst = instance;        this.#na = instance.nodes;        this.#w = width;        this.#mutators.internalJson = mutatorJSON;        if(mutatorJSON.inputs) this.#mutators.hasInputMut = true;        if(mutatorJSON.outputs) this.#mutators.hasOutputMut = true;        for(let input of inputs){            if(input.isMutated){                this.#mutators.state.inputs.data.push(input);            }        }        this.#alwaysGenerate = alwaysGen ?? false;        if(uuid) this.#uuid = uuid;        else this.#uuid = Date.now() + Math.random();        if(isClone){            for(const h of this.#inputs){                if(h.connection) h.connection = null;            }            for(const h of this.#outputs){                if(h.connection) h.connection = null;            }        }        this.#na.push(this);    }}
class NodeConnection{    from;    to;    fromName;    toName;    constructor(from, to, fromName, toName){        this.from = from;        this.to = to;        this.fromName = fromName;        this.toName = toName;    }}class NodeIOHandle{    name = "";    type = "";    connection = null;    integratedInput = false;    hideInput = false;    values = undefined;    inputWidth = 0;    ignoreText = false;    isMutated = false;    value = "";    display = "";    dName = "";    constructor(name, dName = null, code = undefined, values = undefined, display = "", type = "Any", integratedInput = false, hideInput = false,        inputWidth = 0, ignoreText = false){        this.name = name;        this.dName = !dName ? name : dName;        this.values = values;        this.type = type;        this.integratedInput = integratedInput;        this.hideInput = hideInput;        this.display = display;        this.inputWidth = inputWidth;        this.ignoreText = ignoreText;        if(code != undefined && code != null){            this.code = code;        }    }}class ColUtil{    static parseColor(col) {        if (col.startsWith("#")) {            const c = col.slice(1);            const num = parseInt(c, 16);            return {                r: (num >> 16) & 0xFF,                g: (num >> 8) & 0xFF,                b: num & 0xFF            };        }        if (col.startsWith("rgb")) {            const nums = col.match(/\d+/g).map(Number);            return { r: nums[0], g: nums[1], b: nums[2] };        }        throw new Error("Unknown color format: " + col);    }    static toHex({r, g, b}) {        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);    }    static toRGB({r, g, b}) {        return `rgb(${r},${g},${b})`;    }    static darkenColor(col, amt = 40, output = "hex") {        const {r, g, b} = ColUtil.parseColor(col);        const nr = Math.max(0, r - amt);        const ng = Math.max(0, g - amt);        const nb = Math.max(0, b - amt);        if (output === "rgb") return ColUtil.toRGB({r: nr, g: ng, b: nb});        return ColUtil.toHex({r: nr, g: ng, b: nb});    }}
LineBlox.prototype.drawScrollbar = (lb) => {    const canvas = lb.canvas;    const ctx = lb.ctx;    const width = 10;    const subWidth = (width * 2);    const minWidth = 10;    const grip = 5;    const XminX = 0 - lb.scrollX + lb.scrollBarX;    const XmaxY = width;    const XminY = canvas.height - XmaxY - 2;    let Xwidth = canvas.width - (lb.scrollX / lb.scrollIntensityX) - subWidth;    if (Xwidth < minWidth) {        lb.scrollIntensityX = lb.scrollX / (canvas.width - subWidth - minWidth);        Xwidth = minWidth;    }    ctx.fillStyle = "gray";    ctx.fillRect(XminX + lb.scrollX, XminY, Xwidth, XmaxY);    ctx.strokeStyle = "rgba(0, 0, 0, 1)";    ctx.lineWidth = 2;    ctx.strokeRect(XminX + lb.scrollX, XminY, Xwidth, XmaxY);    if(lb.mouseDown && !lb.dragging){        if(lb.mouseX >= XminX + lb.scrollX - grip && lb.mouseX <= XminX + lb.scrollX + Xwidth + grip &&            lb.mouseY >= XminY && lb.mouseY <= XminY + XmaxY){            lb.draggingScrollbarX = true;            lb.scrollBarXOffset = lb.mouseX - (XminX + lb.scrollX);        }    }    if (lb.dragging && lb.draggingScrollbarX) {        const mx = lb.mouseX;        lb.scrollBarX = mx - lb.scrollBarXOffset;        if(lb.scrollBarX < 0)            lb.scrollBarX = 0;        else if(lb.scrollBarX + Xwidth > canvas.width - subWidth)            lb.scrollBarX = canvas.width - Xwidth - subWidth;    }    const YminX = width;    const YbarX = canvas.width - YminX - 2;    let Yheight = canvas.height - (lb.scrollY / lb.scrollIntensityY) - subWidth;    if(Yheight < minWidth){        lb.scrollIntensityY = lb.scrollY / (canvas.height - subWidth - minWidth);        Yheight = minWidth;    }    ctx.fillRect(YbarX, lb.scrollBarY, YminX, Yheight);    ctx.strokeRect(YbarX, lb.scrollBarY, YminX, Yheight);    if(lb.mouseDown && !lb.dragging){        if(lb.mouseX >= YbarX - grip && lb.mouseX <= YbarX + YminX + grip &&            lb.mouseY >= lb.scrollBarY && lb.mouseY <= lb.scrollBarY + Yheight){            lb.draggingScrollbarY = true;            lb.scrollBarYOffset = lb.mouseY - lb.scrollBarY;        }    }    if(lb.dragging && lb.draggingScrollbarY){        const my = lb.mouseY;        lb.scrollBarY = my - lb.scrollBarYOffset;        if(lb.scrollBarY < 0)            lb.scrollBarY = 0;        else if(lb.scrollBarY + Yheight > canvas.height - subWidth)            lb.scrollBarY = canvas.height - Yheight - subWidth;    }}
function updateContentBounds(lb, padding = 200) {    const canvas = lb.canvas;    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;    for (const n of (lb.nodes || [])) {        if (!n) continue;        minX = Math.min(minX, n.x);        minY = Math.min(minY, n.y);        maxX = Math.max(maxX, n.x + (n.width || 0));        maxY = Math.max(maxY, n.y + (n.height || 0));    }    if (!isFinite(minX)) minX = 0;    if (!isFinite(minY)) minY = 0;    if (!isFinite(maxX)) maxX = canvas.width;    if (!isFinite(maxY)) maxY = canvas.height;    lb.contentMinX = minX - padding;    lb.contentMinY = minY - padding;    lb.contentWidth = Math.max(1, (maxX + padding) - lb.contentMinX);    lb.contentHeight = Math.max(1, (maxY + padding) - lb.contentMinY);    lb.scrollX = Math.max(0, Math.min(lb.scrollX || 0, Math.max(0, lb.contentWidth - canvas.width)));    lb.scrollY = Math.max(0, Math.min(lb.scrollY || 0, Math.max(0, lb.contentHeight - canvas.height)));}LineBlox.prototype.drawToolbox = function(lb){    const ctx = lb.toolbox.ctx;    const x = lb.toolbox.size.x;    const sel = lb.toolbox.selected;    const mouse = lb.toolbox.mousePos;    ctx.clearRect(0, 0, lb.toolbox.canvas.width, lb.toolbox.canvas.height);    const lOffset = 6;    const fontSize = 15;    ctx.font = fontSize + "px Sans-Serif";    ctx.textAlign = "left";    ctx.textBaseline = "middle";    let i = 0;    let largestW = 0;    for(const cat of BNodes.toolbox){        const s = ctx.measureText(cat.category).width + fontSize;        largestW = s > largestW ? s : largestW;    }    let cy = 0;    for(const cat of BNodes.toolbox){        ctx.fillStyle = cat.color;        let paint = false;        if(mouse.x > lb.xOffset && mouse.x < largestW &&            mouse.y > cy && mouse.y < cy + fontSize){                if(lb.toolbox.clickedFrame) lb.toolbox.selected = i;                paint = true;            }        if(i == sel) paint = true;        if(paint) ctx.fillRect(0, cy + 2, largestW, fontSize);        else ctx.fillRect(0, cy + 2, lOffset - 2, fontSize);        if(paint) ctx.fillStyle = "white";        ctx.fillText(cat.category, lOffset, cy + fontSize - 4, largestW);        cy += fontSize + 5;        i++;    }    ctx.fillStyle = "gray";    ctx.fillRect(largestW, 0, 3, lb.toolbox.canvas.height);    ctx.fillRect(x - 3, 0, 3, lb.toolbox.canvas.height);    const blockToCategoryIndex = {};    BNodes.toolbox.forEach((cat, idx) => {        for (const block of cat.blocks) {            if (!blockToCategoryIndex[block]) blockToCategoryIndex[block] = [];            blockToCategoryIndex[block].push(idx);        }    });    const canvas = lb.toolbox.canvas;    cy = 10;        let maxY = 0;    for(let node of BNodes.blocks){        const categoryIndices = blockToCategoryIndex[node.internalID] || [];        if(!categoryIndices.includes(sel)) continue;        h = LineBlox.drawDragNode(ctx, node, largestW, cy - lb.toolbox.scrollBarY, lb, 15, x - largestW + 3, true, x);        const hh = (cy + h) - canvas.height;        maxY = hh > maxY ? hh : maxY;        w = node.width;        let _x = largestW + 10 + (x - largestW - 20 - w) / 2;        const mx = lb.toolbox.mousePos.x;        const my = lb.toolbox.mousePos.y;        if(lb.toolbox.clickedFrame && mx > _x && mx < _x + w &&            my > cy && my < cy + h){                lb.toolbox.draggingNodeID = node;            }        cy += h + 10;    }    lb.toolbox.scrollY = maxY;    const YminX = 6;    const YbarX = x - YminX - 2;    const Yheight = canvas.height - lb.toolbox.scrollY - 0;    ctx.fillStyle = "gray";    ctx.fillRect(YbarX, lb.toolbox.scrollBarY, YminX, Yheight);    if((lb.toolbox.clickedFrame || lb.toolbox.draggingScrollbarY) && !lb.toolbox.draggingNodeID){        if(lb.toolbox.mousePos.x >= YbarX && lb.toolbox.mousePos.x <= canvas.width &&            lb.toolbox.mousePos.y >= lb.toolbox.scrollBarY && lb.toolbox.mousePos.y <= lb.toolbox.scrollBarY + Yheight){            lb.toolbox.draggingScrollbarY = true;            lb.toolbox.scrollBarYOffset = lb.toolbox.mousePos.y - lb.toolbox.scrollBarY;        }    }    if(!lb.toolbox.dragging && lb.toolbox.draggingScrollbarY){        const my = lb.toolbox.mousePos.y;        lb.toolbox.scrollBarY = my - lb.toolbox.scrollBarYOffset;        if(lb.toolbox.scrollBarY < 0)            lb.toolbox.scrollBarY = 0;        else if(lb.toolbox.scrollBarY + Yheight > canvas.height - 0)            lb.toolbox.scrollBarY = canvas.height - Yheight - 0;    }}
